diff --git a/Makefile b/Makefile
index 74e454f..7ed6453 100644
--- a/Makefile
+++ b/Makefile
@@ -194,6 +194,11 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_pingpong\
+	$U/_primes\
+	$U/_find\
+	$U/_xargs\
+
 
 
 
diff --git a/user/find.c b/user/find.c
new file mode 100644
index 0000000..22faa24
--- /dev/null
+++ b/user/find.c
@@ -0,0 +1,100 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fs.h"
+#include "kernel/fcntl.h"
+
+char *fmtname(char *path)
+{
+    char *p = path + strlen(path);
+    while (p >= path && *p != '/')
+        p--;
+    return p + 1;
+}
+
+void find(char *path, char *file)
+{
+    char buffer[512], *p;
+    int fd;
+    struct dirent d;
+    struct stat s;
+
+    fd = open(path, O_RDONLY);
+    if (fd < 0)
+    {
+        fprintf(2, "Error: cannot open %s\n", path);
+        return;
+    }
+
+    if (fstat(fd, &s) < 0)
+    {
+        fprintf(2, "Error: cannot stat %s\n", path);
+        close(fd);
+        return;
+    }
+
+    switch (s.type)
+    {
+    case T_FILE:
+        if (strcmp(fmtname(path), file) == 0)
+        {
+            printf("%s\n", path);
+        }
+        break;
+
+    case T_DIR:
+        if (strlen(path) + 1 + DIRSIZ + 1 > sizeof(buffer))
+        {
+            fprintf(2, "Error: path too long\n");
+            break;
+        }
+
+        strcpy(buffer, path);
+        p = buffer + strlen(buffer);
+        *p++ = '/';
+
+        while (read(fd, &d, sizeof(d)) == sizeof(d))
+        {
+            if (d.inum == 0)
+                continue;
+            if (strcmp(d.name, ".") != 0 && strcmp(d.name, "..") != 0)
+            {
+                memmove(p, d.name, DIRSIZ);
+                p[DIRSIZ] = 0;
+
+                if (stat(buffer, &s) < 0)
+                {
+                    fprintf(2, "Error: cannot stat %s\n", buffer);
+                    continue;
+                }
+                find(buffer, file);
+            }
+        }
+        break;
+    }
+
+    close(fd);
+}
+
+int main(int argc, char *argv[])
+{
+    if (argc < 2)
+    {
+        fprintf(2, "Usage: find path file\n");
+        exit(1);
+    }
+
+    if (argc == 2)
+    {
+        find(".", argv[1]);
+    }
+    else
+    {
+        for (int i = 1; i < argc - 1; i++)
+        {
+            find(argv[i], argv[argc - 1]);
+        }
+    }
+
+    exit(0);
+}
diff --git a/user/pingpong.c b/user/pingpong.c
new file mode 100644
index 0000000..b58afac
--- /dev/null
+++ b/user/pingpong.c
@@ -0,0 +1,58 @@
+#include "kernel/types.h"
+#include "user/user.h"
+
+int main(void)
+{
+    int parent_to_child_pipe[2], child_to_parent_pipe[2];
+    char byte = 'a';
+    char buffer[1];
+
+    if (pipe(parent_to_child_pipe) < 0 || pipe(child_to_parent_pipe) < 0)
+    {
+        fprintf(2, "Error: Can't create pipe!\n");
+        exit(1);
+    }
+
+    int pid = fork();
+
+    if (pid < 0)
+    {
+        fprintf(2, "Error: Can't fork!\n");
+        exit(1);
+    }
+
+    if (pid == 0)
+    {
+        close(parent_to_child_pipe[1]);
+        close(child_to_parent_pipe[0]);
+
+        if (read(parent_to_child_pipe[0], buffer, 1) > 0 && buffer[0] == 'a')
+        {
+            printf("%d: received ping\n", getpid());
+        }
+
+        write(child_to_parent_pipe[1], buffer, 1);
+
+        close(parent_to_child_pipe[0]);
+        close(child_to_parent_pipe[1]);
+        exit(0);
+    }
+    else
+    {
+        close(parent_to_child_pipe[0]);
+        close(child_to_parent_pipe[1]);
+
+        write(parent_to_child_pipe[1], &byte, 1);
+
+        if (read(child_to_parent_pipe[0], buffer, 1) > 0 && buffer[0] == 'a')
+        {
+            printf("%d: received pong\n", getpid());
+        }
+
+        close(parent_to_child_pipe[1]);
+        close(child_to_parent_pipe[0]);
+
+        wait(0);
+        exit(0);
+    }
+}
diff --git a/user/primes.c b/user/primes.c
new file mode 100644
index 0000000..782c398
--- /dev/null
+++ b/user/primes.c
@@ -0,0 +1,70 @@
+#include "kernel/types.h"
+#include "user/user.h"
+
+void primes() {
+    int prime_pipe[2];
+    int prime_number;
+
+    if (read(0, (void*)&prime_number, sizeof(prime_number)) <= 0)
+        return;
+
+    printf("prime %d\n", prime_number);
+
+    if (pipe(prime_pipe) < 0) {
+        fprintf(2, "Error: cannot create pipe\n");
+        exit(1);
+    }
+
+    int pid = fork(); 
+    if (pid == 0) {
+        close(0);               
+        dup(prime_pipe[0]);    
+        close(prime_pipe[0]);   
+        close(prime_pipe[1]);   
+        primes();               
+    } else {
+        close(1);               
+        dup(prime_pipe[1]);     
+        close(prime_pipe[0]);  
+        close(prime_pipe[1]);  
+
+        int next_number = 0;
+        while (read(0, (void*)&next_number, sizeof(next_number)) > 0) {
+            if (next_number % prime_number != 0) {
+                write(1, (void*)&next_number, sizeof(next_number));  
+            }
+        }
+        close(1); 
+        wait(&pid);  
+    }
+}
+
+int main(void) {
+    int main_pipe[2]; 
+    if (pipe(main_pipe) < 0) {
+        fprintf(2, "Error: cannot create pipe\n");
+        exit(1);
+    }
+
+    int pid = fork();  
+    if (pid == 0) {
+        close(0);              
+        dup(main_pipe[0]);    
+        close(main_pipe[0]);   
+        close(main_pipe[1]);  
+        primes();              
+    } else {
+        close(1);            
+        dup(main_pipe[1]);     
+        close(main_pipe[0]);   
+        close(main_pipe[1]);   
+
+        for (int i = 2; i <= 280; i++) {
+            write(1, (void*)&i, sizeof(i));
+        }
+
+        close(1);  
+        wait(&pid); 
+    }
+    exit(0);
+}
diff --git a/user/xargs.c b/user/xargs.c
new file mode 100644
index 0000000..692c060
--- /dev/null
+++ b/user/xargs.c
@@ -0,0 +1,92 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+#include "kernel/fcntl.h"
+#include "kernel/param.h"
+
+#define MAXLINE 512  
+
+int
+main(int argc, char *argv[])
+{
+    if (argc < 2) {
+        fprintf(2, "Usage: xargs [-n num] command [args...]\n");
+        exit(1);
+    }
+
+    int maxargs = 1;  
+    int cmd_start = 1; 
+
+    if (strcmp(argv[1], "-n") == 0) {
+        if (argc < 4) {
+            fprintf(2, "Usage: xargs [-n num] command [args...]\n");
+            exit(1);
+        }
+        maxargs = atoi(argv[2]);
+        cmd_start = 3;  
+    }
+
+    char buf[MAXLINE];
+    char *newargv[MAXARG];
+    int n = 0;
+    
+    for (n = 0; n < argc - cmd_start; n++) {
+        newargv[n] = argv[cmd_start + n];
+    }
+
+    int argcount = n;
+
+    while (1) {
+
+        int i = 0;
+        int bytesRead = 0;  
+
+        while (i < MAXLINE) {
+            bytesRead = read(0, &buf[i], 1);  
+            if (bytesRead < 1) {
+                break; 
+            }
+            if (buf[i] == '\n') {
+                buf[i] = 0; 
+                break;
+            }
+            i++;
+        }
+
+        if (i == 0 && bytesRead < 1) {
+            break;
+        }
+
+        newargv[argcount++] = buf;
+
+        if (argcount - n >= maxargs || bytesRead < 1) {
+            newargv[argcount] = 0;  
+
+            if (fork() == 0) {
+                exec(newargv[0], newargv);
+                fprintf(2, "exec %s failed\n", newargv[0]);
+                exit(1);
+            } else {
+               
+                wait(0);
+            }
+
+            argcount = n;
+        }
+    }
+
+    if (argcount > n) {
+        newargv[argcount] = 0;  
+
+        if (fork() == 0) {
+            exec(newargv[0], newargv);
+            fprintf(2, "exec %s failed\n", newargv[0]);
+            exit(1);
+        } else {
+           
+            wait(0);
+        }
+    }
+
+    exit(0);
+}
